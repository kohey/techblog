---
title: "RDSの歴史・immutability・validationについて"
date: 2021-09-12T17:52:28+09:00
draft: false
tags: ["texta.fm", "掃き溜め"]
---

texta.fm#1・2からの学び  
RDBが勢力伸ばした理由、immutability、validationについて。  

<!--more-->
## RDBについて
### ORマッパー誕生の背景
ActiveRecordは、ORマッパーを構成するアーキテクチャパターン  
ORマッパーはObjectモデルとRDSモデルの1:1のインピーダンスミスマッチを解消したかったから。  

### なんでRDSが勢力伸ばした？
インスタンスをDBにストアできれば一番ええやん？ => OODB  
これが一番マッピングもいらんからいいやん  
RDBMS: 資金が潤沢に投入された & 背後の理論が純粋で強固だった => RDBがOODBを上回った  
Railsはデータモデリングが全て的なことがある。DB設計をバチっと決めたら全部上手くいくじゃん。  

---
## immutabilityについて
value obj が immutabilityを満たさないと、値の共有を安全にできなくなる。  
value obj は値によって等価であるとみなすので、インスタンスが違っても同じになりうる。  

### メリット
普遍なので複数prop => 組み合わせで状態を決定する => 穴があるとおかしくなる => このような状態が起こらないことを保証できる  
目の前のことを信頼できる、ということ。
状態が確定している。  


### デメリット
objは短命である場合、メモリの消費が増えること。  
が、小さいobjをガンガン作って、ガンガン消していく、のは、obj志向プログラミングで一番想定されているので、問題なし。    
Railsでreq -> res までに大量のsymbolを作成している。　　


1個のプロセスを効率よく使えれば、あとはスケールアウトさせるだけでは？  
これはnodeのモデル  

ムーアが頭打ちになってきている -> コアを並べてマルチにしよう -> いや、クラウド出てきた -> shared nothing のインスタンスを横に並べて、elastic にスケールさせた方がいいし、冗長性的にもいい。  

---
## validationについて
アサーションエラーと例外の使い分け  
元々は画面に近い存在  

### 契約による設計
・アサーション(表明)  
事前条件の契約 = 守らなかったら知らないぜ？  
事前条件を満たしていないもの、あり得ないでしょ、という状態を弾く  

・例外  
あり得るものを弾く  

### 防御的プログラミング
堅牢性を重んじるときにおきがち。  
メソッドの上にガード節が並ぶやつ  
局所最適になっている = 誰もルール守ってないかもだから、ここではガードする、というのが全体で起きている = 全体では同じようなガードを随所でしている  
全体最適を目指すときに、「やりとりのルールを決めてガードしない」、契約による設計をする  

ユーザに近いところではディフェンスして、それを通ったら、もうガードしないよ。ウチだから。  

### DHH
画面の入力項目って、DBのカラムって、ほとんど一緒っていうか、一緒にできるくない？  
じゃあ一緒にしちゃえば、登場人物減らせるじゃん！  
フォームオブジェクトを不要にできるじゃん。  







